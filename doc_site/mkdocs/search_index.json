{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Suited documentation\n\n\nWhat is it?\n\n\nSuited is a new way to write and present documents. You can write a document once and change what is displayed and how by changing the document mode. As an example, you can take a blog post and turn it into a presentation using the 'deck' mode.\n\n\nBut why?\n\n\nSometimes you write a report on a piece of work only to hear they want you to present the report on Monday. Sometimes you do a cool brown bag presentation and people ask for the slides, but what good are the slides on their own really? Have you ever wished the lecturer had more detail on their slides?  \n\n\nUsing Suited you can create one document to fill all those roles by simply marking out the parts of the document you want to highlight.\n\n\nWe like to think of it as the inverse of a normal presentation slide deck. Instead of slides with embedded speaker notes, you have a document and embedded the slides.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-the-suited-documentation", 
            "text": "", 
            "title": "Welcome to the Suited documentation"
        }, 
        {
            "location": "/#what-is-it", 
            "text": "Suited is a new way to write and present documents. You can write a document once and change what is displayed and how by changing the document mode. As an example, you can take a blog post and turn it into a presentation using the 'deck' mode.", 
            "title": "What is it?"
        }, 
        {
            "location": "/#but-why", 
            "text": "Sometimes you write a report on a piece of work only to hear they want you to present the report on Monday. Sometimes you do a cool brown bag presentation and people ask for the slides, but what good are the slides on their own really? Have you ever wished the lecturer had more detail on their slides?    Using Suited you can create one document to fill all those roles by simply marking out the parts of the document you want to highlight.  We like to think of it as the inverse of a normal presentation slide deck. Instead of slides with embedded speaker notes, you have a document and embedded the slides.", 
            "title": "But why?"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nOverview\n\n\nThis document provides an architectural overview of Suited. It describes the different components that make up Suited and references more detailed descriptions where necessary. Suited is loaded from \ncore.js\n, which is responsible for catching and distributing browser events as well as loading and interpreting the configuration.\n\n\nWhile \nsuited\n is mostly event based some state is managed in a \nState\n object that \nsuited\n maintains.\n\n\nEvents\n\n\nSuited is event based. All browser events are mapped into suited events. All event handling is done by plugins, which are registered with the  \ndispatch\n object when loaded.\n\n\nThe \ndispatch\n sends events to all plugins that have registered a callback for that event. \nPlugin\n's\n can also fire events for others to consume.\n\n\nThe framework generates some lifecycle events and there are some core runtime events related to default features such as changing Mode or slide. Lifecycle events are useful if you want your plugin to run some code or tranform the document after other transformations have run, for instance the Markdown plugin listens to the \nPluginsLoaded\n event and then walks the document transforming markdown into html, it wants the other plugins to be loaded as they may introduce extra dom elements that need to be taken into account.\n\n\nLifecycle Events\n\n\n\n\nConfigLoaded\n:- Configuration has been been consolidated, defaults merges with user supplied overrides.\n\n\nPluginsLoaded\n:- All plugins have been loaded.\n\n\nBeforeSlideChange\n:- slide about to change.\n\n\nAfterSlideChange\n:- slide has changed.\n\n\nBeforeModeChange\n:- Mode is about to change.\n\n\nAfterModeChange\n:- Mode has changed.\n\n\nTODO - not all specified yet.\n\n\n\n\nRuntime Events\n\n\n\n\nLocationChanged\n:-\n\n\neffect:- Updates the URL so bookmarking works and slides have unique REST addresses.\n\n\nfired whenever the \nsuited.state\n has the current slide number changed.\n\n\nusually fired by the builtin plugins such as \nSlideChangePlugin\n but also fired when Modes are changed to update the URL\n\n\n\n\n\n\nSetMode\n:-\n\n\neventdata:- {\"modeName\": a_mode_name}\n\n\neffect:- change to named mode\n\n\nNextMode\n:-\n\n\neffect:- change to next mode\n\n\nSetModeNum\n:-\n\n\neventdata:- {\"modeNum\": a_mode_number}\n\n\neffect:- change to next mode\n\n\n\n\nReserved key events\n\n\nThe \ncore.js\n listens to browser events such as key presses and clicks for the core features. The handlers simple fire \nsuited\n events for the builtin plugins to handle. While you can also add a plugin to listen to these \nsuited\n events should not attempt to change the browser event handlers for these keys.\n\n\nKey listeners\n\n\n\n\n\"left arrow\"\n\n\nfires:-\n\n\nBeforeSlideChange\n\n\nGoBack\n\n\nAfterSlideChange\n\n\n\n\n\n\neffect:- go to previous slide or figure.\n\n\n\"right arrow\"\n\n\nfires:-\n\n\nBeforeSlideChange\n\n\nGoForward\n\n\nAfterSlideChange\n\n\n\n\n\n\neffect:- go to next slide or figure.\n\n\n\"s\"\n\n\nfires:-\n\n\nNextMode\n\n\nLocationChanged\n passing in current state\n\n\n\n\n\n\neffect:- switch to next mode.\n\n\n\"1 -\n 9\"\n\n\nfires:-\n\n\nSetModeNum\n with eventdata {\"modeNum\": num}\n\n\n\n\n\n\neffect:- change to mode of same number\n\n\n\"SHIFT+t\"\n\n\nfires:-\n\n\nLocationChanged\n\n\n\n\n\n\neffect:- go to top of document\n\n\n\"escape key\"\n\n\nfires:-\n\n\nESC\n\n\n\n\n\n\neffect:- jump back to default doc mode.\n\n\n\"enter key\"\n\n\nfires:-\n\n\nENTER\n\n\n\n\n\n\n\"any other key press\"\n\n\nfires:-\n\n\n\"KEY_PRESSED_\" + javascript key code\n\n\neg KEY_PRESSED_90 key 'z' pressed\n\n\n\n\n\n\n\n\nclick listeners\n\n\n\n\n'left mouse click'\n\n\nfires:-\n\n\nCLICK\n:-\n\n\neventdata:- the browser click event\n\n\neffect:- not specified\n\n\n\n\n\n\n\n\nmouse move listeners\n\n\n\n\n'mouse moved'\n\n\neffect:- sets the \nsuited.mouseX\n and \nsuited.mouseY\n variables\n\n\n\n\nPlugins\n\n\nPlugins are the workhorses of \nsuited\n.\nThey listen to events and modify the display of the document.\n\n\nA plugin defines callbacks for events.\n\n\nPlugins must have a unique \nname\n if two have the same name then the second one loaded will replace the first.\n\n\nPlugins must have a 'registerCallbacks(dispatch)' and a 'deregisterCallbacks(dispatch)' method or function that calls `dispatch.on(eventName, callback)``\n\n\nIt is recomended that you use plugin.js's \nnew Plugin(name)\n constructor then this will all be taken care of for you.\n\n\nWhen Suited adds a plugin it first tests that \nregisterCallbacks\n adds callbacks and \nderegisterCallbacks\n\ncompleatly removes them before allowing the plugin to be added.\n\n\nIf your plugin uses plugin.js's \nnew Plugin(name)\n constructor then it will also have the \naddCallback(eventname, callbackFunc, valueHandler)\n function, where valueHandler is optional, which can be used to add a callback for an event to a plugin.\n\n\nA Callback is a \nfunction(state, eventData)\n. \nstate\n is an object managed by suited and has an \nAPI\n\n\nBoth state and eventData are optional, but if the callback modifies the state (by using the State API),\nthen it must return an object that contains the new state,\neg return `{state: someNewState}``\n\n\nMany callbacks may be called in turn for a particular event, The \ndispatch\n makes sure that the state returned is\npassed to the next callback.\n\n\nIn addition to returning state, a callback may return a value\neg return {state: somestate, value: calculation }\n\n\nNormally nothing will be done withthat value, however if you wish to handle It then you\ncan supply an optional 3rd parameter to Plugin.addCallback(). The 3rd parameter is a \"valueHandler'\nfunction. It expects to be passed the callback's return object and can then extract the value and do whatever it needs to do with it.\n\n\nBuiltin Plugins\n\n\n\n\nLocationManagerPlugin\n\n\nFixes the URL after a mode or slide change.\n\n\nlistens to:- \nLocationChanged\n event.\n\n\nMarkdownPlugin\n\n\nrenders markdown in data-markdown elements to HTML\n\n\nlistens to:- \nPluginsLoaded\n event.\n\n\nSlideChangePlugin\n\n\nmodifies \nstate\n to reflect the next navigable slide and fires the currentMode's transition function.\n\n\nlistens to:- \nGoBack\n and \nGoForward\n event.\n\n\nfires:- \nLocationChanged\n\n\nModePlugin\n\n\nresponsible for setting the current \nMode\n and setting up a \nstyle\n placeholder for Modes to attach custom style to.\n\n\nlistens to:- \nNextMode\n, \nPrevMode\n, \nSetMode\n, \nSetModeNum\n and \nESC\n\n\nfires:- \nBeforeModeChange\n, \nAfterModeChange\n to allow modes to setup and teardown and DOM or style changes that they make.\n\n\nfires:- \nBeforeSlideChange\n and \nAfterSlideChange\n to allow the Mode to dress the current slide as if it had just been transitioned to rat in the new Mode rhather than simply changing mode.\n\n\nfires:- \nModeCSSFree\n to let the new mode that the previous modes style placehoder has been cleaned up and it is free to add style if it chooses.\n\n\nfires \nLocationChanged\n in the event of receiving \nESC\n because it not only chnages to default mode but moves the navigation pointer back to the top of the document.\n\n\n\n\nTechnically the builtin Modes are also plugins but they willl be discussed below.\n\n\nModes\n\n\nMode\n's\n are responsible for the look and feel of the document.\n\n\nTechnically they are plugins and extent from \nPlugin\n but rather than all being loaded/registered with \nsuited\n only one Mode is loaded at a time by the \nModePlugin\n.\n\n\nBeing plugins, they must have unique names, and their actions are triggered by registering callbacks to the lifecycle events. However they are special special plugins and must also define a transition function that is fired when moving from one slide to the next.\n\n\nModes are plugins and can also add callbacks for custom events that they may actually fire themselves in their normal function. For example the \nlecture\n mode listens the the default Lifecycle events but also listens to the CLICK event and ENTER upon which it zooms the document.\n\n\nIt is recomended that you you create your own modes using \nnew Mode(modeName, fnBeforeSlideChange, fnAfterSlideChange, fnBeforeModeChange, fnAfterModeChange, fnCleanUp, fnShouldShowslide, arrTransitions)\n. all but modeName parameter are optional parameters, but if nothing is supplied it will be a boring Mode.\n\n\nfnBeforeSlideChange\n, \nfnAfterSlideChange\n, \nfnBeforeModeChange\n, \nfnAfterModeChange\n are plugin callbacks that fire on the lifecycle events \nBeforeSlideChange\n, \nAfterSlideChange\n, \nBeforeModeChange\n and \nAfterModeChange\n respectivly. If null then the mode performs no action on those events. Common actions would be changing the style or class of the new and old slides to modify the display or adding extra DOM elements to the document as needed by the mode or its transitions.\n\n\nfnCleanUp\n should remove and trace that the Mode existed reverting the document to its state before the Mode was applied.\n\n\nfnShouldShowslide\n is a predicate function that returns true if a slide is to be displayed, if false the navigation will skip it and move to the next. While this could be fancy and run different rules for each slide or consult state to determine if a slide is to display, the default Modes only use it to descriminate between \ndata-figure\n and \ndata-slide\n \nsection\n's'. Most Modes only display the \ndata-figure\n sections while \ndeck\n mode is the slide deck and shows both. In this way it is posssible to add slides to the deck that dont show up in the \ndoc\n view of the document. If this function is null then all are displayed by that mode.\n\n\narrTransitions\n is an array of transition objects that the mode supports, with the first one being a default.\n\n\nMode transitions.\n\n\nA transition object is used to swap slides, it had functions that handle the swap direction and looks like:-\n\n\n{\n  \nname\n: \nunique_name_in_mode\n,\n  \ntop\n: function goToTopOfDoc(),\n  \nleft\n: function goToPreviousSlide(),\n  \nright\n function goToNextSlide(),\n  \nup\n: function goUpaSlide(),\n  \ndown\n: function goDownASlide()\n}\n\n\n\n\nIf no transitions are specified then the default \"scroll\" transition is used.\n\n\nThe transition used is either the Mode's default or the one specified in suited.config for the Mode or one specified by name in the \"transition\" attribute of a slide section. If a mode supports that named transition and displayed that slide it will use the specified transition whenever it transitions to that slide. eg.\n\n\nsection data-figure transition=\njump\n\n    \nimg src=\nimages/jackOfSpades.png\n width=\n60%\n /\n\n\n/section\n\n\n\n\n\nBuiltin Modes\n\n\n\n\ndoc\n\n\nintent:- display the document as a normal document.\n\n\ndoesn't modify the DOM or style and displays all elements but only data-figure slides.\n\n\ndefault \"scroll\" transition.\n\n\ndeck\n\n\nslide deck mode.\n\n\ndisplays ONLY the data-figures and data-slides.\n\n\nintent:- present as aslide show for a talk or meetup.\n\n\ndefault \"jump\" transition\n\n\nwalkthrough\n\n\nlike doc but add a highlight background to each data-figure as it navigates to it.\n\n\nlecture\n\n\nintent: allow a lecturer to walk through a document discussing it.\n\n\nlike \ndoc\n but\n\n\nlistens to: \"CLICK\" event:- zooms the element clicked.\n\n\nlistens to: \"ENTER\" evnet:- zooms the currently navigated to slide.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#overview", 
            "text": "This document provides an architectural overview of Suited. It describes the different components that make up Suited and references more detailed descriptions where necessary. Suited is loaded from  core.js , which is responsible for catching and distributing browser events as well as loading and interpreting the configuration.  While  suited  is mostly event based some state is managed in a  State  object that  suited  maintains.", 
            "title": "Overview"
        }, 
        {
            "location": "/architecture/#events", 
            "text": "Suited is event based. All browser events are mapped into suited events. All event handling is done by plugins, which are registered with the   dispatch  object when loaded.  The  dispatch  sends events to all plugins that have registered a callback for that event.  Plugin 's  can also fire events for others to consume.  The framework generates some lifecycle events and there are some core runtime events related to default features such as changing Mode or slide. Lifecycle events are useful if you want your plugin to run some code or tranform the document after other transformations have run, for instance the Markdown plugin listens to the  PluginsLoaded  event and then walks the document transforming markdown into html, it wants the other plugins to be loaded as they may introduce extra dom elements that need to be taken into account.", 
            "title": "Events"
        }, 
        {
            "location": "/architecture/#lifecycle-events", 
            "text": "ConfigLoaded :- Configuration has been been consolidated, defaults merges with user supplied overrides.  PluginsLoaded :- All plugins have been loaded.  BeforeSlideChange :- slide about to change.  AfterSlideChange :- slide has changed.  BeforeModeChange :- Mode is about to change.  AfterModeChange :- Mode has changed.  TODO - not all specified yet.", 
            "title": "Lifecycle Events"
        }, 
        {
            "location": "/architecture/#runtime-events", 
            "text": "LocationChanged :-  effect:- Updates the URL so bookmarking works and slides have unique REST addresses.  fired whenever the  suited.state  has the current slide number changed.  usually fired by the builtin plugins such as  SlideChangePlugin  but also fired when Modes are changed to update the URL    SetMode :-  eventdata:- {\"modeName\": a_mode_name}  effect:- change to named mode  NextMode :-  effect:- change to next mode  SetModeNum :-  eventdata:- {\"modeNum\": a_mode_number}  effect:- change to next mode", 
            "title": "Runtime Events"
        }, 
        {
            "location": "/architecture/#reserved-key-events", 
            "text": "The  core.js  listens to browser events such as key presses and clicks for the core features. The handlers simple fire  suited  events for the builtin plugins to handle. While you can also add a plugin to listen to these  suited  events should not attempt to change the browser event handlers for these keys.", 
            "title": "Reserved key events"
        }, 
        {
            "location": "/architecture/#key-listeners", 
            "text": "\"left arrow\"  fires:-  BeforeSlideChange  GoBack  AfterSlideChange    effect:- go to previous slide or figure.  \"right arrow\"  fires:-  BeforeSlideChange  GoForward  AfterSlideChange    effect:- go to next slide or figure.  \"s\"  fires:-  NextMode  LocationChanged  passing in current state    effect:- switch to next mode.  \"1 -  9\"  fires:-  SetModeNum  with eventdata {\"modeNum\": num}    effect:- change to mode of same number  \"SHIFT+t\"  fires:-  LocationChanged    effect:- go to top of document  \"escape key\"  fires:-  ESC    effect:- jump back to default doc mode.  \"enter key\"  fires:-  ENTER    \"any other key press\"  fires:-  \"KEY_PRESSED_\" + javascript key code  eg KEY_PRESSED_90 key 'z' pressed", 
            "title": "Key listeners"
        }, 
        {
            "location": "/architecture/#click-listeners", 
            "text": "'left mouse click'  fires:-  CLICK :-  eventdata:- the browser click event  effect:- not specified", 
            "title": "click listeners"
        }, 
        {
            "location": "/architecture/#mouse-move-listeners", 
            "text": "'mouse moved'  effect:- sets the  suited.mouseX  and  suited.mouseY  variables", 
            "title": "mouse move listeners"
        }, 
        {
            "location": "/architecture/#plugins", 
            "text": "Plugins are the workhorses of  suited .\nThey listen to events and modify the display of the document.  A plugin defines callbacks for events.  Plugins must have a unique  name  if two have the same name then the second one loaded will replace the first.  Plugins must have a 'registerCallbacks(dispatch)' and a 'deregisterCallbacks(dispatch)' method or function that calls `dispatch.on(eventName, callback)``  It is recomended that you use plugin.js's  new Plugin(name)  constructor then this will all be taken care of for you.  When Suited adds a plugin it first tests that  registerCallbacks  adds callbacks and  deregisterCallbacks \ncompleatly removes them before allowing the plugin to be added.  If your plugin uses plugin.js's  new Plugin(name)  constructor then it will also have the  addCallback(eventname, callbackFunc, valueHandler)  function, where valueHandler is optional, which can be used to add a callback for an event to a plugin.  A Callback is a  function(state, eventData) .  state  is an object managed by suited and has an  API  Both state and eventData are optional, but if the callback modifies the state (by using the State API),\nthen it must return an object that contains the new state,\neg return `{state: someNewState}``  Many callbacks may be called in turn for a particular event, The  dispatch  makes sure that the state returned is\npassed to the next callback.  In addition to returning state, a callback may return a value\neg return {state: somestate, value: calculation }  Normally nothing will be done withthat value, however if you wish to handle It then you\ncan supply an optional 3rd parameter to Plugin.addCallback(). The 3rd parameter is a \"valueHandler'\nfunction. It expects to be passed the callback's return object and can then extract the value and do whatever it needs to do with it.", 
            "title": "Plugins"
        }, 
        {
            "location": "/architecture/#builtin-plugins", 
            "text": "LocationManagerPlugin  Fixes the URL after a mode or slide change.  listens to:-  LocationChanged  event.  MarkdownPlugin  renders markdown in data-markdown elements to HTML  listens to:-  PluginsLoaded  event.  SlideChangePlugin  modifies  state  to reflect the next navigable slide and fires the currentMode's transition function.  listens to:-  GoBack  and  GoForward  event.  fires:-  LocationChanged  ModePlugin  responsible for setting the current  Mode  and setting up a  style  placeholder for Modes to attach custom style to.  listens to:-  NextMode ,  PrevMode ,  SetMode ,  SetModeNum  and  ESC  fires:-  BeforeModeChange ,  AfterModeChange  to allow modes to setup and teardown and DOM or style changes that they make.  fires:-  BeforeSlideChange  and  AfterSlideChange  to allow the Mode to dress the current slide as if it had just been transitioned to rat in the new Mode rhather than simply changing mode.  fires:-  ModeCSSFree  to let the new mode that the previous modes style placehoder has been cleaned up and it is free to add style if it chooses.  fires  LocationChanged  in the event of receiving  ESC  because it not only chnages to default mode but moves the navigation pointer back to the top of the document.   Technically the builtin Modes are also plugins but they willl be discussed below.", 
            "title": "Builtin Plugins"
        }, 
        {
            "location": "/architecture/#modes", 
            "text": "Mode 's  are responsible for the look and feel of the document.  Technically they are plugins and extent from  Plugin  but rather than all being loaded/registered with  suited  only one Mode is loaded at a time by the  ModePlugin .  Being plugins, they must have unique names, and their actions are triggered by registering callbacks to the lifecycle events. However they are special special plugins and must also define a transition function that is fired when moving from one slide to the next.  Modes are plugins and can also add callbacks for custom events that they may actually fire themselves in their normal function. For example the  lecture  mode listens the the default Lifecycle events but also listens to the CLICK event and ENTER upon which it zooms the document.  It is recomended that you you create your own modes using  new Mode(modeName, fnBeforeSlideChange, fnAfterSlideChange, fnBeforeModeChange, fnAfterModeChange, fnCleanUp, fnShouldShowslide, arrTransitions) . all but modeName parameter are optional parameters, but if nothing is supplied it will be a boring Mode.  fnBeforeSlideChange ,  fnAfterSlideChange ,  fnBeforeModeChange ,  fnAfterModeChange  are plugin callbacks that fire on the lifecycle events  BeforeSlideChange ,  AfterSlideChange ,  BeforeModeChange  and  AfterModeChange  respectivly. If null then the mode performs no action on those events. Common actions would be changing the style or class of the new and old slides to modify the display or adding extra DOM elements to the document as needed by the mode or its transitions.  fnCleanUp  should remove and trace that the Mode existed reverting the document to its state before the Mode was applied.  fnShouldShowslide  is a predicate function that returns true if a slide is to be displayed, if false the navigation will skip it and move to the next. While this could be fancy and run different rules for each slide or consult state to determine if a slide is to display, the default Modes only use it to descriminate between  data-figure  and  data-slide   section 's'. Most Modes only display the  data-figure  sections while  deck  mode is the slide deck and shows both. In this way it is posssible to add slides to the deck that dont show up in the  doc  view of the document. If this function is null then all are displayed by that mode.  arrTransitions  is an array of transition objects that the mode supports, with the first one being a default.", 
            "title": "Modes"
        }, 
        {
            "location": "/architecture/#mode-transitions", 
            "text": "A transition object is used to swap slides, it had functions that handle the swap direction and looks like:-  {\n   name :  unique_name_in_mode ,\n   top : function goToTopOfDoc(),\n   left : function goToPreviousSlide(),\n   right  function goToNextSlide(),\n   up : function goUpaSlide(),\n   down : function goDownASlide()\n}  If no transitions are specified then the default \"scroll\" transition is used.  The transition used is either the Mode's default or the one specified in suited.config for the Mode or one specified by name in the \"transition\" attribute of a slide section. If a mode supports that named transition and displayed that slide it will use the specified transition whenever it transitions to that slide. eg.  section data-figure transition= jump \n     img src= images/jackOfSpades.png  width= 60%  /  /section", 
            "title": "Mode transitions."
        }, 
        {
            "location": "/architecture/#builtin-modes", 
            "text": "doc  intent:- display the document as a normal document.  doesn't modify the DOM or style and displays all elements but only data-figure slides.  default \"scroll\" transition.  deck  slide deck mode.  displays ONLY the data-figures and data-slides.  intent:- present as aslide show for a talk or meetup.  default \"jump\" transition  walkthrough  like doc but add a highlight background to each data-figure as it navigates to it.  lecture  intent: allow a lecturer to walk through a document discussing it.  like  doc  but  listens to: \"CLICK\" event:- zooms the element clicked.  listens to: \"ENTER\" evnet:- zooms the currently navigated to slide.", 
            "title": "Builtin Modes"
        }
    ]
}